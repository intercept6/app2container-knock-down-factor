# アプリケーションのコンテナ化の際のノックダウン条件

## この資料は？

オンプレミスやEC2インスタンス上で動いているアプリケーションをコンテナ化する際に、修正しなければ移行が不可能になったりアーキテクチャへ悪影響を与えてしまう要素をまとめた資料です。

## 一覧

| 要素 | 理由 | 対処方法 | 応急対応 | 
| --- | --- | --- | --- |
| ログをファイルに保存している | 永続保管が必要なログをファイルとして保持し続けることができない。 | ログの出力先を標準出力に変換する。ログ種別に応じてファイルを分けていた場合は、FluentdのようなソフトウェアかLambda関数を使ってログの内容に基づいて振り分けを行う。 | 共有ボリュームにログを保存し、Fluentdのようなソフトウェアでログを読み取って外部へ転送する。</br> https://dev.classmethod.jp/articles/fargate-fluentd-s3/ </br></br>EFSをマウントしファイルの保存先にする。 |
| クライアントからファイルをアップロードされている | 永続保管が必要なファイルを保持し続けることができない。アップロード後に外部へ転送する場合でもタイミングがスケールインと被るとロストしてしまう。 | アップロード前にクライアントへS3バケットへアップロードする為のPre-Signed URLを発行し、アップロードさせる。 | EFSをマウントしファイルの保存先にする。 |
| セッション情報を内部に保持している | スケールイン発生時にセッション情報が失われてしまう(Auto Scalingを使わないならコンテナ化する必要性が薄い) | ElastiCache for Redis / for Memcachedにセッション情報を保存する。Webアプリケーションフレームワークを使っているなら対応している場合が多いのでまずはドキュメントを確認する。 | ELBにALBを採用しスティッキーセッションを有効にし、Auto Scalingの設定でコンテナ数を固定値にする。 |